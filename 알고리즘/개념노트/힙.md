# π” ν™(Heap)
1. κ°μ²΄λ¥Ό μ €μ¥ν•λ”λ° μ‚¬μ©λλ” λ™μ  λ©”λ¨λ¦¬ κ³µκ°„
2. μλ°”μ—μ„λ” μ£Όλ΅ μ°μ„ μμ„ νλ¥Ό κµ¬ν„ν•  λ• μ‚¬μ© λ¨.
3. λ¶€λ¨-μμ‹ λ…Έλ“ κ΄€κ³„ : λ¶€λ¨ λ…Έλ“λ” ν•­μƒ μμ‹ λ…Έλ“λ³΄λ‹¤ μ°μ„ μμ„κ°€ λ†’κ±°λ‚ κ°™μ€ κ°’μ„ κ°€μ§„λ‹¤. <Br/>
μµλ€ ν™μ€ λ¶€λ¨ λ…Έλ“κ°€ ν•­μƒ μμ‹λ³΄λ‹¤ ν° κ°’, μµμ† ν™μ€ ν•­μƒ λ¶€λ¨ λ…Έλ“κ°€ μμ‹λ³΄λ‹¤ μ‘μ€ κ°’μ„ κ°€μ§„λ‹¤.


```java
PriorityQueue<Integer> minH = new PriorityQueue<>(); //μµμ† ν™
PriorityQueue<Integer> maxH = new PriorityQueue<>(Collections.reverseOrder()); //μµλ€ ν™

//μ‚½μ…
minH.offer(1);

//μµμ†κ°’ ν™•μΈ
min.peek();

//μµμ†κ°’ μ‚­μ 
//μ°μ„ μμ„κ°€ κ°€μ¥ λ†’μ€ μ”μ†λ¥Ό μ‚­μ λλ‹¤.
min.poll();
```

## π¥ μ¤νƒ / ν / μ°μ„ μμ„ν(ν™μΌλ΅ κµ¬ν„ν•)μ μ—°μ‚°λ³„ μ‹κ°„λ³µμ΅λ„

### π¥ μ¤νƒ
- μ‚½μ…(Push): O(log n) 
- μ‚­μ (Pop): O(log n)
- νƒ‘ μ”μ† ν™•μΈ(Peek): O(1)

### π¥ ν
- μ‚½μ…(Enqueue): O(log n)
- μ‚­μ (Dequeue): O(log n)
- μ• μ”μ† ν™•μΈ(Peek or Front): O(1)

### π¥ μ°μ„ μμ„ν
- μ‚½μ…(Insert): O(log n)
- μµλ€/μµμ†κ°’ μ‚­μ (Extract Max/Min): O(log n)
- μµλ€/μµμ†κ°’ ν™•μΈ(Peek Max/Min): O(1)